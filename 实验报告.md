# ICS Project 实验报告

## 目录

- #### [分工](#0)
- #### [代码结构](#1)
- #### [运行方法](#2)
- #### [实现的功能](#3)
- #### [实现细节](#4)
- #### [心路历程与展望](#5)

## <span id="0">分工</span>

后端代码编写：			崔晨昊、祁昊

前端代码编写：			崔晨昊

stage1后端代码调试：崔晨昊、祁昊

stage2后端代码调试：祁昊、崔晨昊

实验报告撰写：			崔晨昊

PPT制作：					  祁昊

## <span id="1">代码结构</span>

提交的代码中，有一些头文件和cpp文件，这些文件是后端的源码。Makefile主要是为了方便编译出dll文件供前端调用。gui文件夹下，pyw文件是前端的源码，exe文件是经过打包后可执行文件。

**以下是文件的依赖关系和具体文件详解**

R.h
↑
F_Reg.h、D_Reg.h、E_Reg.h、W_Reg.h、W_Reg.h
↑
TOP.h TOP.cpp
↑
common.h
↑
FETCH.h、DECODE.h、EXECUTE.h、MEMORY.h、WBACK.h
↑
main.cpp

CCH_QH.dll

↑
Y86模拟器.pyw



#### R.h:

包含REGISTER类(64位数据)、REGISTERS类的属性、方法的声明。在实现REGISTER类时，使用了union联合，可以将数据解释为longlong 或 char数组，前者方便内存的寻址，后者方便赋值。

#### F_Reg.h、D_Reg.h、E_Reg.h、W_Reg.h、W_Reg.h:

包含五个流水线寄存器类的属性、方法的声明

#### TOP.h TOP.cpp:

声明所有的全局变量

#### common.h:

用extern关键字声明全局变量，之后的文件include"common.h"即可

#### FETCH.h、DECODE.h、EXECUTE.h、MEMORY.h、WBACK.h

五个阶段类的属性、方法的声明。使用类来封装是为了便于使用统一的接口，以及在不同命名空间下用同一方法名，避免了函数的混乱。

#### main.cpp

为前端提供接口，主运行函数

#### COLOR.py

定义一些颜色常量 PS：好像只用到了黑色和白色

#### READ.py

调用ctype库，使用dll中的函数接口，做一些预处理

#### Y86模拟器.pyw

绘制主要的图形界面以及窗口事件响应

## <span id="2">运行方法</span>

双击gui下Y86模拟器.exe文件即可运行。

在弹出的对话框中选择要打开的测试文件(注意，由于前端在处理文件时读取字符的方式比较机械，我们手动修改了honor样例，做了一些简单的对齐、缩进处理，请直接打开honor-example文件夹下的样例即可)

单击屏幕右下角的NEXT、按键盘→键、↓键、鼠标滚轮下滚均可以使CPU执行一个时间周期。

按下键盘A键，可以将模拟器设为自动运行，再次按下A键，仍切换回手动运行状态。(见窗口右上角AUTO、MANUAL标识)

AUTO状态下按键盘上的=键可以调快速度，按-键可以减慢速度

CPU出现halt、domain error、invalid instructon等状态时，模拟器会停止运行。

## <span id="3">实现的功能</span>

后端实现了CPU流水线的基本功能，同时结合了荣誉样例，在异常处理、代码鲁棒性等方面做了一些考虑和修改。例如将存储指令的内存部分设为不可修改(在测试谭助教给的样例时将该功能暂时移除)，以及domain error等基本的内存访问错误。前端提供了每个时钟周期更新前，五个流水线寄存器的属性值、15个寄存器的值、三个condition code的值以及程序运行状态。

## <span id="4">实现细节</span>

我们将按照模拟器exe程序执行的顺序来讲解代码上的实现细节。

#### Y86模拟器.pyw

利用pyinstaller对python程序进行打包时，文件相对路径读取极有可能出错(会被修改成pyinstaller的执行位置)，而app_path()函数则利用了冻结路径，解决了这个危险。使得打包过后的exe文件也能根据相对路径找到要读取的文件。

之后读取了背景图片、利用tkinter读取当前屏幕大小而非pygame读取电脑分辨率以免受笔记本电脑缩放而产生的一些问题、以及数据在窗口展示位置的预先设置。

init_ins()函数通过tkinter.filedialog.askopenfile()方法，弹出窗口，双击可以打开文件。然后利用字符串的切割等处理技术，对文件字符串进行处理，合并为一个完整的指令字符串。之后将该字符串传入C++程序，做一些处理，存入内存。在传参时，使用了.encode()方法，将python字符串编码为二进制，去除了空白字符缓冲区，方便C++程序的读取和处理。

refresh函数调用了READ.py里的函数，主要利用C++接口读取需要读取的值。以及设置在窗口展示的位置。

pygame主循环内，设置了flag、run、AUTO三个控制变量，刷新屏幕的间隔定的是30ms。AUTO为自动运行的控制变量，flag是该次循环是否需要调用主执行函数(一个完整时钟周期)的控制量，执行完毕之后，flag设为0 or AUTO。run是屏幕时间是否有效的控制函数，当程序遇到halt、domain error、invalid instruction时，run设为0，此时即便出现窗口事件，flag的值仍为0，不会继续调用主执行函数。

#### READ.py

READ.py加载了dll库，并对接口函数做了一些处理。将ctype产生的函数对象的.restype属性设为c_longlong，使得python可以用long long类型接受C++函数返回值。

#### main.cpp

在讲main.cpp前先来讲一下我们的后端程序组织架构。

最底层的是R.cpp，其中定义了一个REGISTER类。这个数据类型是我们整个后端程序的灵魂。REGISTER类实际上是一个存储64位数据的类，它定义了一些读和写的接口。在实现REGISTER类的时候，我一开始想的是直接用一个八位的char来存储，因为我们的内存也是以char为字节存储的。原本是打算写一个char数组到long long的转换函数，后来想起来，在测试机器是小短法还是大短法时，有一种测试方法就是利用union，建立一个long long和char[8]的联合。那么我们不是也可以这样吗！指令在内存中也是小端法存储，在union中同样保留了这样的性质不变，按照小端法存储的char数组，转换成long long时可以正确的读取出来！当然利用union也不是完全没有弊端。由于union天生不能设置为常量，导致我们无法自己写复制构造函数(参数需要是常引用)。万幸，C++的类自己为我们偷偷生成了一个复制构造函数，这使得我们所有的函数调用以及赋值都得以正常进行(C++万岁！)。同时也定义了一个REGISTERS类，用于实例化寄存器文件。这个不再赘述。

比R.cpp高一层的是五个流水线寄存器，即X_reg.cpp。他们引入了R.h，使得它们可以使用REGISTER类对属性进行处理。每个流水线寄存器类均有读、写接口。

再高一层的是top.cpp，top中声明了后端所有的全局变量。包含五个流水线寄存器的实例、寄存器文件的实例、内存数组、condition code、以及几个用于流水线控制逻辑的值(e_dstE,m_stat,e_Cnd,d_srcA,d_srcB)，由于仅在下一个时钟周期开始时才更新流水线寄存器，所以如果要用到其他阶段的属性值，需要借助全局变量来实现这些数据的读写。

然后是common.h，common.h是一个头文件，里面包含了需要include的库以及用extern声明的全局变量。

而FETCH、DECODE、EXECUTE、MEMORY、WBACK五个类建立在common之上，它们读取、修改这些声明后的全局变量，并做相应的操作。

最后是main.cpp。main.cpp中定义了所有需要被python调用的接口函数，全部用extern "C"使函数名保持原样。主要的函数是init_memory和CCH_QH(没错就是用小组成员名字来命名)。

init_memory接受一个字符串指针，并对该字符串做一个处理，将两个acsii码表示的'0'~'F'的字符转换为二进制值并拼接到一个char中，这个过程应用了一点位运算(感谢datalab)。同时也一道更新了instr_length，记录了指令长度。

CCH_QH是主要的执行函数，每次调用函数时，首先将fetch等类的本地值写入流水线寄存器，再调用各个操作类的操作方法(读取、执行)。由于流水线的控制逻辑，这里的顺序显得极为重要。因为F_stall依赖于D_reg、E_reg、M_reg的值，D_bubble依赖于E_reg、M_reg的值，所以对F_reg的写操作应放在最后，对D_Reg的写操作应放在倒数第二个。

更新完五个流水线寄存器之后，进行五个阶段的执行操作。由于涉及全局变量的读取，顺序同样很重要。decode的数据转发逻辑依赖于execute产生的e_dstE、e_valE，所以decode要放在execute的后面。

#### FETCH.cpp

定义FRTCH类，尝试使用了函数指针(后来发现这样并不好，二维的函数指针数组有点浪费空间了)，可以直接根据icode、ifun读取到对应要执行的函数。访问二维数组，非法指令会调用invalid，将各属性值设为bubble()，stat设为4。Initfunc函数就是用于初始化函数指针数组。

SelectPC方法主要用于选择pc值，当检测到预测错误或是ret到达写回阶段时，选择对应流水线寄存器的值。否则使用F_reg的pc值。

在做对应函数操作的时候，增加了pcoverflow标志，检测是否pc值超出指令长度(即指令末尾出现问题)，如果超出，执行invalid。

write函数用于向下一级流水线寄存器，也就是D_reg写数据。我们用“在写之前检测并决定是否修改属性值为bubble的值”的方法进行气泡的插入，用“在写数据之前直接return”的方法实现D_stall，令D_reg的值不变。

#### DECODE.cpp

定义DECODE类，read函数用于从D_Reg中读取数据。如果状态码不对，就直接跳过后面，直接return。
cal_dstE、call_dstM、call_srcA、call_srcB四个函数是根据icode来设置对应属性的值。

SelFwdA、SelFwdB是主要的处理数据转发逻辑的函数。用if-else的级联实现了数据转发的优先级。在使用e_valE的值时，多加了一个判断，即不能上一个周期的execute执行的是pop %rsp，并且我们正要使用rsp，因为如果是这样，那么本周期内memory读取pop出来的值，m_valM才是正确的rsp，而非e_valE可能产生的rsp+8。

#### EXECUTE.cpp

定义了EXECUTE类。一些基本函数和FETCH的组织方式一致，多了一个setcc标志，如果需要设置condition code，就用本地的属性更新全局的CC。同时在cmovxx、jxx等函数检测是否预测错误，依此设立cond的值，并赋给e_Cnd(用于数据转发)

在write函数中兼顾了异常处理，当W_reg的状态码不为1时，不进行写操作。

#### MEMORY.cpp

getAddr函数用于根据icode从valE、valA中选择合适的值作为地址。之后read_memory和write_memory则是对内存进行写操作。

#### WBACK.cpp

对寄存器的值进行写回操作，不再赘述。

## <span id="5">心路历程与展望</span>

由于我本人(崔晨昊)的失误，没有仔细研究书本上的各种机制，贸然就开始写代码，我写的两个类的实现基本都是错误的。直到stage1加分ddl第二天的下午，我才算是完全通透，明白了所有的组织框架，然后一路debug高歌猛进，在晚上通过了所有样例。

不得不说，在我没有掌握整体知识之前，debug的过程异常地艰辛。这里修修，那里补补，结构上有根本的问题，还是换汤不换药。加分ddl前一天晚上熬到1点多，其他三四天每天都是坐在电脑前一坐4,5个小时，有时午饭也来不及吃。
debug的过程绝望与希望并存，压力与收获共行。高考以来，我一直都是处于一种赋闲的状态，这次确实逼了自己一把，全身心地投入到这件事情上来。

样例通过的那天晚上，看到寄存器显示的是正常的值，眼睛一下子就酸了，也是在那一刻，给自己施加的芜杂而庞大的压力找到了一个情绪的宣泄口。

这次的PJ对我来说确实受益良多，能有机会使用自己比较熟悉的pygame包写一点前端的东西也确实令我很快乐。


我们的模拟器也还有很多需要发展的地方，例如：加入cache机制、加入断点设置、加入回溯机制等